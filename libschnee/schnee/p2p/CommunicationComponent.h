#pragma once
#include "CommunicationDelegate.h"
#include <schnee/tools/Serialization.h>
#include <schnee/tools/Deserialization.h>

namespace sf {

/**
 * Base class for all fundamental Protocols. It can receive half-parsed packets and can answer to them
 * via the CommunicationDelegate Interface.
 *
 * A datapacket is a Datagram whose header can be parsed to " $CMD $JSON-Code", where $CMD defines which component
 * to use and the $JSON-Code will be passed to the component.
 *
 * CommunicationComponent is used in CommunicationMultiplex. InterplexBeacon is a CommunicationMultiplex.
 *
 *
 */
class CommunicationComponent {
public:
	virtual ~CommunicationComponent () {}

	///@name Incoming Traffic
	///@{

	/// The component gets the packet
	/// Note: usually generated by SF_AUTOREFLECT_RPC
	virtual bool handleRpc (const sf::HostId &, const sf::String & cmdName, const sf::Deserialization & header, const sf::ByteArray & data = sf::ByteArray()) = 0;

	///@}

	///@{ Information about the component
	///@{

	/// Name of the CommunicationComponent
	/// Note: usually generated by SF_AUTOREFLECT_RPC
	virtual const char * name () const = 0;

	/// A 0-terminated list of commands the CommunicationComponent Accepts.
	/// Note: usually generated by SF_AUTOREFLECT_RPC
	virtual const char ** commands () const = 0;

	///@}

	///@name Information about changes
	///@{
	
	virtual void onChannelChange (const HostId & host) {}

	///@}

	///@name CommunicationDelegate connection
	///@{

	/// Sets a delegate, so that the Protocol is able to communicate
	virtual void setDelegate (CommunicationDelegate * com) {
		mCommunicationDelegate = com;
	}
	
	///@}

protected:
	CommunicationDelegate * mCommunicationDelegate;
};


}
